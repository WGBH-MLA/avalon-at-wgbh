{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\")); // Colors for segments from Avalon branding pallette\n\n\nvar COLOR_PALETTE = ['#80A590', '#2A5459', '#FBB040'];\n\nvar WaveformDataUtils =\n/*#__PURE__*/\nfunction () {\n  function WaveformDataUtils() {\n    (0, _classCallCheck2[\"default\"])(this, WaveformDataUtils);\n  }\n\n  (0, _createClass2[\"default\"])(WaveformDataUtils, [{\n    key: \"initSegments\",\n\n    /**\n     * Initialize Peaks instance for the app\n     * @param {Array} smData - current structured metadata from the server masterfile\n     */\n    value: function initSegments(smData) {\n      var _this = this;\n\n      var initSegments = [];\n      var count = 0; // Recursively build segments for timespans in the structure\n\n      var createSegment = function createSegment(items) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var item = _step.value;\n\n            if (item.type === 'span') {\n              count = count > 1 ? 0 : count;\n\n              var segment = _this.convertTimespanToSegment(item);\n\n              initSegments.push((0, _objectSpread2[\"default\"])({}, segment, {\n                color: COLOR_PALETTE[count]\n              }));\n              count++;\n            }\n\n            if (item.items && item.items.length > 0) {\n              createSegment(item.items);\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }; // Build segments from initial metadata structure\n\n\n      createSegment(smData);\n      return initSegments;\n    }\n    /**\n     * Add a temporary segment to be edited when adding a new timespan to structure\n     * @param {Object} peaksInstance - peaks instance for the current waveform\n     */\n\n  }, {\n    key: \"insertTempSegment\",\n    value: function insertTempSegment(peaksInstance) {\n      var _this2 = this; // Current time of the playhead\n\n\n      var currentTime = this.roundOff(peaksInstance.player.getCurrentTime()); // End time of the media file\n\n      var fileEndTime = this.roundOff(peaksInstance.player.getDuration());\n      var rangeEndTime,\n          rangeBeginTime = currentTime;\n      var currentSegments = this.sortSegments(peaksInstance, 'startTime'); // Validate start time of the temporary segment\n\n      currentSegments.map(function (segment) {\n        if (rangeBeginTime >= segment.startTime && rangeBeginTime <= segment.endTime) {\n          // rounds upto 2 decimal points for accuracy\n          rangeBeginTime = _this2.roundOff(segment.endTime);\n        }\n\n        return rangeBeginTime;\n      }); // Set the default end time of the temporary segment\n\n      if (currentSegments.length === 0) {\n        rangeEndTime = fileEndTime < 60 ? fileEndTime : Math.round((rangeBeginTime + 60.0) * 100) / 100;\n      } else {\n        rangeEndTime = Math.round((rangeBeginTime + 60.0) * 100) / 100;\n      } // Validate end time of the temporary segment\n\n\n      currentSegments.map(function (segment) {\n        if (rangeBeginTime < segment.startTime) {\n          var segmentLength = segment.endTime - segment.startTime;\n\n          if (fileEndTime < 60) {\n            rangeEndTime = fileEndTime;\n          }\n\n          if (segmentLength < 60 && rangeEndTime >= segment.startTime) {\n            rangeEndTime = segment.startTime;\n          }\n\n          if (rangeEndTime >= segment.startTime && rangeEndTime < segment.endTime) {\n            rangeEndTime = segment.startTime;\n          }\n        }\n\n        if (rangeEndTime > fileEndTime) {\n          rangeEndTime = fileEndTime;\n        }\n\n        return rangeEndTime;\n      });\n\n      if (rangeBeginTime < fileEndTime && rangeEndTime > rangeBeginTime) {\n        // Move playhead to start of the temporary segment\n        peaksInstance.player.seek(rangeBeginTime);\n        peaksInstance.segments.add({\n          startTime: rangeBeginTime,\n          endTime: rangeEndTime,\n          editable: true,\n          color: COLOR_PALETTE[2],\n          id: 'temp-segment'\n        });\n      }\n\n      return peaksInstance;\n    }\n    /**\n     * Delete the corresponding segment when a timespan is deleted\n     * @param {Object} item - item to be deleted\n     * @param {Object} peaksInstance - peaks instance for the current waveform\n     */\n\n  }, {\n    key: \"deleteSegments\",\n    value: function deleteSegments(item, peaksInstance) {\n      var deleteChildren = function deleteChildren(item) {\n        var children = item.items;\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var child = _step2.value;\n\n            if (child.type === 'span') {\n              peaksInstance.segments.removeById(child.id);\n            }\n\n            if (child.items && child.items.length > 0) {\n              deleteChildren(child);\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n              _iterator2[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      };\n\n      if (item.type === 'div') {\n        deleteChildren(item);\n      }\n\n      peaksInstance.segments.removeById(item.id);\n      return peaksInstance;\n    }\n    /**\n     * Update the colors of the segment to alternate between colors in Avalon color pallette\n     * @param {Object} peaksInstance - current peaks instance for the waveform\n     */\n\n  }, {\n    key: \"rebuildPeaks\",\n    value: function rebuildPeaks(peaksInstance) {\n      var _this3 = this;\n\n      var clonedSegments = this.sortSegments(peaksInstance, 'startTime');\n      peaksInstance.segments.removeAll();\n      clonedSegments.forEach(function (segment, index) {\n        segment.color = _this3.isOdd(index) ? COLOR_PALETTE[1] : COLOR_PALETTE[0];\n        peaksInstance.segments.add(segment);\n      });\n      return peaksInstance;\n    }\n    /**\n     * Change color and add handles for editing the segment in the waveform\n     * @param {String} id - ID of the segment to be edited\n     * @param {Object} peaksInstance - current peaks instance for the waveform\n     */\n\n  }, {\n    key: \"activateSegment\",\n    value: function activateSegment(id, peaksInstance) {\n      // Remove the current segment\n      var _peaksInstance$segmen = peaksInstance.segments.removeById(id),\n          _peaksInstance$segmen2 = (0, _slicedToArray2[\"default\"])(_peaksInstance$segmen, 1),\n          removedSegment = _peaksInstance$segmen2[0]; // Create a new segment with the same properties and set editable to true\n\n\n      peaksInstance.segments.add((0, _objectSpread2[\"default\"])({}, removedSegment, {\n        editable: true,\n        color: COLOR_PALETTE[2]\n      }));\n      var startTime = peaksInstance.segments.getSegment(id).startTime; // Move play head to the start time of the selected segment\n\n      peaksInstance.player.seek(startTime);\n      return peaksInstance;\n    }\n    /**\n     * Revert color and remove handles for editing of the segment\n     * @param {String} id - ID of the segment being saved\n     * @param {Object} peaksInstance - current peaks instance for the waveform\n     */\n\n  }, {\n    key: \"deactivateSegment\",\n    value: function deactivateSegment(id, peaksInstance) {\n      // Sorted segments by start time\n      var segments = this.sortSegments(peaksInstance, 'startTime');\n      var index = segments.map(function (seg) {\n        return seg.id;\n      }).indexOf(id); // Remove the current segment\n\n      var _peaksInstance$segmen3 = peaksInstance.segments.removeById(id),\n          _peaksInstance$segmen4 = (0, _slicedToArray2[\"default\"])(_peaksInstance$segmen3, 1),\n          removedSegment = _peaksInstance$segmen4[0]; // Create a new segment and revert to its original color\n\n\n      peaksInstance.segments.add((0, _objectSpread2[\"default\"])({}, removedSegment, {\n        editable: false,\n        color: this.isOdd(index) ? COLOR_PALETTE[1] : COLOR_PALETTE[0]\n      }));\n      return peaksInstance;\n    }\n    /**\n     * Save the segment into the Peaks\n     * @param {Object} currentState - current values for the timespan to be saved\n     * @param {Object} peaksInstance - current peaks instance for waveform\n     */\n\n  }, {\n    key: \"saveSegment\",\n    value: function saveSegment(currentState, peaksInstance) {\n      var beginTime = currentState.beginTime,\n          endTime = currentState.endTime,\n          clonedSegment = currentState.clonedSegment;\n      peaksInstance.segments.removeById(clonedSegment.id);\n      peaksInstance.segments.add((0, _objectSpread2[\"default\"])({}, clonedSegment, {\n        startTime: this.toMs(beginTime),\n        endTime: this.toMs(endTime)\n      }));\n      return peaksInstance;\n    }\n    /**\n     * Reverse the changes made in peaks waveform when changes are cancelled\n     * @param {Object} clonedSegment - cloned segment before changing peaks waveform\n     * @param {Object} peaksInstance - current peaks instance for wavefrom\n     */\n\n  }, {\n    key: \"revertSegment\",\n    value: function revertSegment(clonedSegment, peaksInstance) {\n      peaksInstance.segments.removeById(clonedSegment.id);\n      peaksInstance.segments.add(clonedSegment);\n      return peaksInstance;\n    }\n    /**\n     * Update Peaks instance when user changes the start and end times from the edit forms\n     * @param {Object} segment - segment related to timespan\n     * @param {Object} currentState - current begin and end times from the input form\n     * @param {Object} peaksInstance - current peaks instance for waveform\n     */\n\n  }, {\n    key: \"updateSegment\",\n    value: function updateSegment(segment, currentState, peaksInstance) {\n      var beginTime = currentState.beginTime,\n          endTime = currentState.endTime;\n      var beginSeconds = this.toMs(beginTime);\n      var endSeconds = this.toMs(endTime);\n\n      if (beginSeconds < segment.endTime && segment.startTime !== beginSeconds) {\n        var _peaksInstance$segmen5 = peaksInstance.segments.removeById(segment.id),\n            _peaksInstance$segmen6 = (0, _slicedToArray2[\"default\"])(_peaksInstance$segmen5, 1),\n            removed = _peaksInstance$segmen6[0];\n\n        peaksInstance.segments.add((0, _objectSpread2[\"default\"])({}, removed, {\n          startTime: beginSeconds\n        }));\n        return peaksInstance;\n      }\n\n      if (endSeconds > segment.startTime && segment.endTime !== endSeconds) {\n        var _peaksInstance$segmen7 = peaksInstance.segments.removeById(segment.id),\n            _peaksInstance$segmen8 = (0, _slicedToArray2[\"default\"])(_peaksInstance$segmen7, 1),\n            _removed = _peaksInstance$segmen8[0];\n\n        peaksInstance.segments.add((0, _objectSpread2[\"default\"])({}, _removed, {\n          endTime: endSeconds\n        }));\n        return peaksInstance;\n      }\n\n      return peaksInstance;\n    }\n    /**\n     * Prevent the times of segment being edited overlapping with the existing segments\n     * @param {Object} segment - segement being edited in the waveform\n     * @param {Object} peaksInstance - current peaks instance for waveform\n     */\n\n  }, {\n    key: \"validateSegment\",\n    value: function validateSegment(segment, peaksInstance) {\n      var allSegments = peaksInstance.segments.getSegments();\n      var duration = this.roundOff(peaksInstance.player.getDuration());\n      var startTime = segment.startTime,\n          endTime = segment.endTime; // segments before and after the editing segment\n\n      var _this$findWrapperSegm = this.findWrapperSegments(segment, allSegments),\n          before = _this$findWrapperSegm.before,\n          after = _this$findWrapperSegm.after; // index of the segment in the arrays\n\n\n      var segmentIndex = allSegments.map(function (seg) {\n        return seg.id;\n      }).indexOf(segment.id);\n\n      for (var i = 0; i < allSegments.length; i++) {\n        var current = allSegments[i];\n\n        if (current.id == segment.id) {\n          continue;\n        }\n\n        if (startTime > current.startTime && endTime < current.endTime) {\n          segment.startTime = current.endTime;\n          segment.endTime = current.endTime + 0.01;\n        } else if (duration - 0.01 <= endTime && endTime <= duration && after && after.id === current.id) {\n          segment.endTime = after.startTime;\n        } else if (before && before.id === current.id && startTime < before.endTime) {\n          segment.startTime = before.endTime;\n        } else if (after && after.id === current.id && endTime > after.startTime) {\n          segment.endTime = after.startTime;\n        } else if (startTime > current.startTime && startTime < current.endTime) {\n          segment.startTime = i < segmentIndex ? current.endTime : current.startTime;\n        } else if (endTime > current.startTime && endTime < current.endTime) {\n          segment.endTime = i < segmentIndex ? current.startTime : current.endTime;\n        } else if (segment.startTime === segment.endTime) {\n          segment.endTime = segment.startTime + 0.01;\n        } else if (endTime > duration) {\n          segment.endTime = duration;\n        }\n      }\n\n      return segment;\n    }\n    /**\n     * Convert timespan to segment to be consumed within peaks instance\n     * @param {Object} timespan\n     */\n\n  }, {\n    key: \"convertTimespanToSegment\",\n    value: function convertTimespanToSegment(timespan) {\n      var begin = timespan.begin,\n          end = timespan.end,\n          label = timespan.label,\n          id = timespan.id;\n      return {\n        startTime: this.toMs(begin),\n        endTime: this.toMs(end),\n        labelText: label,\n        id: id\n      };\n    }\n    /**\n     * Find the before and after segments of a given segment\n     * @param {Object} currentSegment - current segment being added/edited\n     * @param {Array} allSegments - segments in the current peaks instance\n     */\n\n  }, {\n    key: \"findWrapperSegments\",\n    value: function findWrapperSegments(currentSegment, allSegments) {\n      var _this4 = this;\n\n      var wrapperSegments = {\n        before: null,\n        after: null\n      };\n      var startTime = currentSegment.startTime,\n          endTime = currentSegment.endTime;\n      var timeFixedSegments = allSegments.map(function (seg) {\n        return (0, _objectSpread2[\"default\"])({}, seg, {\n          startTime: _this4.roundOff(seg.startTime),\n          endTime: _this4.roundOff(seg.endTime)\n        });\n      });\n      wrapperSegments.after = timeFixedSegments.filter(function (seg) {\n        return seg.startTime > startTime;\n      })[0];\n      var segmentsBefore = timeFixedSegments.filter(function (seg) {\n        return seg.endTime < endTime;\n      });\n\n      if (segmentsBefore) {\n        wrapperSegments.before = segmentsBefore[segmentsBefore.length - 1];\n      }\n\n      return wrapperSegments;\n    }\n  }, {\n    key: \"isOdd\",\n    value: function isOdd(num) {\n      return num % 2;\n    }\n  }, {\n    key: \"toMs\",\n    value: function toMs(strTime) {\n      var _strTime$split = strTime.split(':'),\n          _strTime$split2 = (0, _slicedToArray2[\"default\"])(_strTime$split, 3),\n          hours = _strTime$split2[0],\n          minutes = _strTime$split2[1],\n          seconds = _strTime$split2[2];\n\n      var hoursAndMins = parseInt(hours) * 3600 + parseInt(minutes) * 60;\n      var secondsIn = seconds === '' ? 0.0 : parseFloat(seconds);\n      return hoursAndMins + secondsIn;\n    }\n  }, {\n    key: \"sortSegments\",\n    value: function sortSegments(peaksInstance, sortBy) {\n      var allSegments = peaksInstance.segments.getSegments();\n      return allSegments.sort(function (x, y) {\n        return x[sortBy] - y[sortBy];\n      });\n    }\n  }, {\n    key: \"roundOff\",\n    value: function roundOff(value) {\n      var valueString = '';\n\n      var _value$toString$split = value.toString().split('.'),\n          _value$toString$split2 = (0, _slicedToArray2[\"default\"])(_value$toString$split, 2),\n          intVal = _value$toString$split2[0],\n          decVal = _value$toString$split2[1];\n\n      if (!decVal) {\n        valueString = intVal;\n      } else {\n        valueString = intVal + '.' + decVal.substring(0, 2);\n      }\n\n      return parseFloat(valueString);\n    }\n  }]);\n  return WaveformDataUtils;\n}();\n\nexports[\"default\"] = WaveformDataUtils;","map":null,"metadata":{},"sourceType":"module"}