{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getExistingFormValues = getExistingFormValues;\nexports.getValidationBeginState = getValidationBeginState;\nexports.getValidationEndState = getValidationEndState;\nexports.getValidationTitleState = getValidationTitleState;\nexports.isTitleValid = isTitleValid;\nexports.validTimespans = validTimespans;\n\nvar _StructuralMetadataUtils = _interopRequireDefault(require(\"./StructuralMetadataUtils\"));\n\nvar _WaveformDataUtils = _interopRequireDefault(require(\"./WaveformDataUtils\"));\n\nvar structuralMetadataUtils = new _StructuralMetadataUtils[\"default\"]();\nvar waveformDataUtils = new _WaveformDataUtils[\"default\"]();\n/**\n * Load existing form values to state, if in 'EDIT' mode\n */\n\nfunction getExistingFormValues(id, smData) {\n  var peaks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var item = structuralMetadataUtils.findItem(id, smData); // Heading\n\n  if (item.type === 'div' || item.type === 'root') {\n    return {\n      headingTitle: item.label\n    };\n  } // Timespan\n\n\n  if (item.type === 'span') {\n    var parentDiv = structuralMetadataUtils.getParentDiv(item, smData);\n    return {\n      beginTime: item.begin,\n      endTime: item.end,\n      timespanChildOf: parentDiv ? parentDiv.id : '',\n      timespanTitle: item.label,\n      clonedSegment: peaks.segments.getSegment(id)\n    };\n  }\n}\n\nfunction getValidationBeginState(beginTime, allSpans) {\n  if (!beginTime || beginTime.indexOf(':') === -1) {\n    return null;\n  }\n\n  var validFormat = structuralMetadataUtils.validTimeFormat(beginTime);\n  var validBeginTime = structuralMetadataUtils.doesTimeOverlap(beginTime, allSpans);\n\n  if (validFormat && validBeginTime) {\n    return 'success';\n  }\n\n  if (!validFormat || !validBeginTime) {\n    return 'error';\n  }\n\n  return null;\n}\n\nfunction getValidationEndState(beginTime, endTime, allSpans, peaksInstance) {\n  var duration;\n\n  if (peaksInstance !== undefined) {\n    if (peaksInstance.player !== undefined) {\n      duration = waveformDataUtils.roundOff(peaksInstance.player.getDuration());\n    }\n  }\n\n  if (!endTime || endTime.indexOf(':') === -1) {\n    return null;\n  }\n\n  var validFormat = structuralMetadataUtils.validTimeFormat(endTime);\n  var validEndTime = structuralMetadataUtils.doesTimeOverlap(endTime, allSpans, duration);\n  var validOrdering = structuralMetadataUtils.validateBeforeEndTimeOrder(beginTime, endTime);\n  var doesTimespanOverlap = structuralMetadataUtils.doesTimespanOverlap(beginTime, endTime, allSpans);\n\n  if (validFormat && validEndTime && validOrdering && !doesTimespanOverlap) {\n    return 'success';\n  }\n\n  if (!validFormat || !validEndTime || !validOrdering || doesTimespanOverlap) {\n    return 'error';\n  }\n\n  return null;\n}\n\nfunction getValidationTitleState(title) {\n  if (title.length > 2) {\n    return 'success';\n  }\n\n  if (title.length > 0) {\n    return 'error';\n  }\n\n  return null;\n}\n/**\n * Validation logic for a valid title here\n * @param {String} title\n */\n\n\nfunction isTitleValid(title) {\n  return title.length > 2;\n}\n/**\n * Validates that the begin and end time span values are valid separately, and together\n * in the region which they will create.\n *\n * This function also preps handy feedback messages we might want to display to the user\n */\n\n\nfunction validTimespans(beginTime, endTime, allSpans, peaksInstance) {\n  var duration;\n\n  if (peaksInstance !== undefined) {\n    if (peaksInstance.player !== undefined) {\n      duration = waveformDataUtils.roundOff(peaksInstance.player.getDuration());\n    }\n  } // Valid formats?\n\n\n  if (!structuralMetadataUtils.validTimeFormat(beginTime)) {\n    return {\n      valid: false,\n      message: 'Invalid begin time format'\n    };\n  }\n\n  if (!structuralMetadataUtils.validTimeFormat(endTime)) {\n    return {\n      valid: false,\n      message: 'Invalid end time format'\n    };\n  } // Any individual overlapping?\n\n\n  if (!structuralMetadataUtils.doesTimeOverlap(beginTime, allSpans)) {\n    return {\n      valid: false,\n      message: 'Begin time overlaps an existing timespan region'\n    };\n  }\n\n  if (!structuralMetadataUtils.doesTimeOverlap(endTime, allSpans)) {\n    return {\n      valid: false,\n      message: 'End time overlaps an existing timespan region'\n    };\n  } // Begin comes before end?\n\n\n  if (!structuralMetadataUtils.validateBeforeEndTimeOrder(beginTime, endTime)) {\n    return {\n      valid: false,\n      message: 'Begin time must start before end time'\n    };\n  } // Timespan range overlaps an existing timespan?\n\n\n  if (structuralMetadataUtils.doesTimespanOverlap(beginTime, endTime, allSpans)) {\n    return {\n      valid: false,\n      message: 'New timespan region overlaps an existing timespan region'\n    };\n  } // Timespan end time is greater than end time of the media file\n\n\n  if (duration < structuralMetadataUtils.toMs(endTime) / 1000) {\n    return {\n      valid: false,\n      message: 'End time overlaps duration of the media file'\n    };\n  } // Success!\n\n\n  return {\n    valid: true\n  };\n}","map":null,"metadata":{},"sourceType":"module"}