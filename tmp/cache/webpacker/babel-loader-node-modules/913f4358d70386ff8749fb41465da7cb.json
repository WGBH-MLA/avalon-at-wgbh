{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _lodash = require(\"lodash\");\n\nvar _moment = _interopRequireDefault(require(\"moment\"));\n\nvar _v = _interopRequireDefault(require(\"uuid/v1\"));\n/**\n * Rules - https://github.com/avalonmediasystem/avalon/issues/3022\n *\n * a timespan does not allow overlap.\n * a timepan can not be out of order.\n * a timespan can not be demoted from a parent unless it is the last item in the relationship (last child), as it would create an out of order item.\n * Timespans can only be moved ONE parent- level up or down.\n * Use an arrow and handle click.\n * Only first and last time-spans can be moved. Middle Children are stuck.\n * Headings are ordered by the children they have.\n * If when creating a timespan, you butt against the start or end of another timespan, you have to change the other timepan first.\n * Labels can be edited at will.\n */\n\n\nvar StructuralMetadataUtils =\n/*#__PURE__*/\nfunction () {\n  function StructuralMetadataUtils() {\n    var _this = this;\n\n    (0, _classCallCheck2[\"default\"])(this, StructuralMetadataUtils);\n    (0, _defineProperty2[\"default\"])(this, \"dndHelper\", {\n      addSpanBefore: function addSpanBefore(parentDiv, allItems, wrapperSpanBefore) {\n        var beforeParent = _this.getParentDiv(wrapperSpanBefore, allItems);\n\n        var beforeSiblings = beforeParent.items;\n        var beforeIndex = beforeSiblings.map(function (item) {\n          return item.id;\n        }).indexOf(wrapperSpanBefore.id); // Before the insert, check that the dropTarget index doesn't already exist\n\n        if (beforeSiblings[beforeIndex + 1] && beforeSiblings[beforeIndex + 1].type !== 'optional' && parentDiv.id !== beforeParent.id) {\n          beforeSiblings.splice(beforeIndex + 1, 0, _this.createDropZoneObject());\n        }\n      },\n      addSpanAfter: function addSpanAfter(parentDiv, allItems, wrapperSpanAfter) {\n        var afterParent = _this.getParentDiv(wrapperSpanAfter, allItems);\n\n        var afterSiblings = afterParent.items;\n        var afterIndex = afterSiblings.map(function (item) {\n          return item.id;\n        }).indexOf(wrapperSpanAfter.id);\n\n        if (afterSiblings[afterIndex - 1] && afterSiblings[afterIndex - 1].type !== 'optional' && parentDiv.id !== afterParent.id) {\n          afterSiblings.splice(afterIndex, 0, _this.createDropZoneObject());\n        }\n\n        if (afterIndex === 0 && parentDiv.id !== afterParent.id) {\n          afterSiblings.splice(afterIndex, 0, _this.createDropZoneObject());\n        }\n      },\n      stuckInMiddle: function stuckInMiddle(spanIndex, siblings, parentDiv) {\n        return spanIndex !== 0 && spanIndex !== siblings.length - 1 && parentDiv.items[spanIndex - 1].type === 'span' && parentDiv.items[spanIndex + 1].type === 'span';\n      },\n      addSpanToEmptyHeader: function addSpanToEmptyHeader(parentDiv, allItems) {\n        var wrapperParents = _this.findWrapperHeaders(parentDiv, allItems);\n\n        if (wrapperParents.after) {\n          if (wrapperParents.after.items) {\n            wrapperParents.after.items.splice(0, 0, _this.createDropZoneObject());\n          } else {\n            wrapperParents.after.items = [_this.createDropZoneObject()];\n          }\n        }\n      }\n    });\n  }\n\n  (0, _createClass2[\"default\"])(StructuralMetadataUtils, [{\n    key: \"createDropZoneObject\",\n\n    /**\n     * Helper function to create a dropZone object for drag and drop\n     * @returns {Object}\n     */\n    value: function createDropZoneObject() {\n      return {\n        type: 'optional',\n        id: (0, _v[\"default\"])()\n      };\n    }\n    /**\n     * Helper function which creates an object with the shape our data structure requires\n     * @param {Object} obj\n     * @return {Object}\n     */\n\n  }, {\n    key: \"createSpanObject\",\n    value: function createSpanObject(obj) {\n      return {\n        id: (0, _v[\"default\"])(),\n        type: 'span',\n        label: obj.timespanTitle,\n        begin: obj.beginTime,\n        end: obj.endTime\n      };\n    }\n    /**\n     * Remove a targeted list item object from data structure\n     * @param {String} id - list item id\n     * @param {Array} allItems array of items, usually all current items in the data structure\n     * @return {Array}\n     */\n\n  }, {\n    key: \"deleteListItem\",\n    value: function deleteListItem(id, allItems) {\n      var clonedItems = (0, _lodash.cloneDeep)(allItems);\n      var item = this.findItem(id, allItems);\n      var parentDiv = this.getParentDiv(item, clonedItems);\n      var indexToDelete = (0, _lodash.findIndex)(parentDiv.items, {\n        id: item.id\n      });\n      parentDiv.items.splice(indexToDelete, 1);\n      return clonedItems;\n    }\n    /**\n     * Format the time of the timespans in the structured metadata fetched from the server,\n     * so that they can be used in the validation logic and Peaks instance\n     * @param {Array} allItems - array of all the items in structured metadata\n     * @param {Float} duration - end time of the media file in Milliseconds\n     */\n\n  }, {\n    key: \"buildSMUI\",\n    value: function buildSMUI(allItems, duration) {\n      var _this2 = this; // Regex to match mm:ss OR single number\n\n\n      var regexMMSS = /^([0-9]*:[0-9]*.[0-9]*)$/i;\n      var regexSS = /^([0-9]*.[0-9]*)$/i; // Round duration to 2 decimal places\n\n      var fileLength = Math.round(duration / 10) / 100; // Convert time to HH:mm:ss.ms format to use in validation logic\n\n      var convertToHHmmss = function convertToHHmmss(time) {\n        if (regexMMSS.test(time)) {\n          var _time$split = time.split(':'),\n              _time$split2 = (0, _slicedToArray2[\"default\"])(_time$split, 2),\n              minutes = _time$split2[0],\n              seconds = _time$split2[1];\n\n          var minutesIn = parseInt(minutes) * 60;\n          var secondsIn = seconds === '' ? 0.0 : parseFloat(seconds);\n          return minutesIn + secondsIn;\n        }\n\n        if (regexSS.test(time)) {\n          return parseFloat(time);\n        } else {\n          return _this2.toMs(time) / 1000;\n        }\n      }; // Recursive function to traverse whole data structure\n\n\n      var formatTime = function formatTime(items) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var item = _step.value;\n\n            if (item.type === 'span') {\n              var begin = item.begin,\n                  end = item.end;\n              var beginTime = convertToHHmmss(begin);\n              var endTime = convertToHHmmss(end);\n              item.begin = _this2.toHHmmss(beginTime);\n\n              if (beginTime > endTime) {\n                item.end = _this2.toHHmmss(fileLength);\n              } else {\n                item.end = _this2.toHHmmss(endTime);\n              }\n            }\n\n            if (item.items) {\n              formatTime(item.items);\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      };\n\n      formatTime(allItems);\n      return allItems;\n    }\n    /**\n     * Update the data structure to represent all possible dropTargets for the provided dragSource\n     * @param {Object} dragSource\n     * @param {Object} allItems\n     * @returns {Array} - new computed items\n     */\n\n  }, {\n    key: \"determineDropTargets\",\n    value: function determineDropTargets(dragSource, allItems) {\n      var clonedItems = (0, _lodash.cloneDeep)(allItems);\n\n      if (dragSource.type === 'span') {\n        var wrapperSpans = this.findWrapperSpans(dragSource, this.getItemsOfType('span', clonedItems));\n        var parentDiv = this.getParentDiv(dragSource, clonedItems);\n        var siblings = parentDiv ? parentDiv.items : [];\n        var spanIndex = siblings.map(function (sibling) {\n          return sibling.id;\n        }).indexOf(dragSource.id);\n        var stuckInMiddle = this.dndHelper.stuckInMiddle(spanIndex, siblings, parentDiv); // If span falls in the middle of other spans, it can't be moved\n\n        if (stuckInMiddle) {\n          return clonedItems;\n        } // Sibling before is a div?\n\n\n        if (spanIndex !== 0 && siblings[spanIndex - 1].type === 'div') {\n          var sibling = siblings[spanIndex - 1];\n\n          if (sibling.items) {\n            sibling.items.push(this.createDropZoneObject());\n          } else {\n            sibling.items = [this.createDropZoneObject()];\n          }\n        } // Sibling after is a div?\n\n\n        if (spanIndex !== siblings.length - 1 && siblings[spanIndex + 1].type === 'div') {\n          var _sibling = siblings[spanIndex + 1];\n\n          if (_sibling.items) {\n            _sibling.items.unshift(this.createDropZoneObject());\n          } else {\n            _sibling.items = [this.createDropZoneObject()];\n          }\n        }\n\n        var grandParentDiv = this.getParentDiv(parentDiv, clonedItems); // A first/last child of siblings, or an only child\n\n        if (grandParentDiv !== null) {\n          var siblingTimespans = this.getItemsOfType('span', siblings);\n          var timespanIndex = siblingTimespans.map(function (sibling) {\n            return sibling.id;\n          }).indexOf(dragSource.id);\n          var parentIndex = grandParentDiv.items.map(function (item) {\n            return item.id;\n          }).indexOf(parentDiv.id);\n\n          if (timespanIndex === 0) {\n            grandParentDiv.items.splice(parentIndex, 0, this.createDropZoneObject());\n          }\n\n          if (timespanIndex === siblingTimespans.length - 1) {\n            var newPI = grandParentDiv.items.map(function (item) {\n              return item.id;\n            }).indexOf(parentDiv.id);\n            grandParentDiv.items.splice(newPI + 1, 0, this.createDropZoneObject());\n          }\n        } // Insert after the \"before\" wrapper span (if one exists)\n\n\n        if (wrapperSpans.before) {\n          this.dndHelper.addSpanBefore(parentDiv, clonedItems, wrapperSpans.before);\n        } // Insert relative to the span after the active span\n\n\n        if (wrapperSpans.after) {\n          this.dndHelper.addSpanAfter(parentDiv, clonedItems, wrapperSpans.after);\n        } // Insert when there is no wrapper span after active span, but empty headers\n\n\n        if (!wrapperSpans.after) {\n          this.dndHelper.addSpanToEmptyHeader(parentDiv, clonedItems);\n        }\n      }\n\n      return clonedItems;\n    }\n    /**\n     * Helper object for drag and drop data structure manipulations\n     * This mutates the state of the data structure\n     */\n\n  }, {\n    key: \"doesTimeOverlap\",\n\n    /**\n     * Determine whether a time overlaps (or falls between), an existing timespan's range\n     * @param {String} time - form input value\n     * @param {*} allSpans - all timespans in the data structure\n     * @return {Boolean}\n     */\n    value: function doesTimeOverlap(time, allSpans) {\n      var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.MAX_SAFE_INTEGER;\n      var toMs = this.toMs;\n      var valid = true;\n      time = toMs(time); // Loop through all spans\n\n      for (var i in allSpans) {\n        var spanBegin = toMs(allSpans[i].begin);\n        var spanEnd = toMs(allSpans[i].end); // Illegal time (falls between existing start/end times)\n\n        if (time > spanBegin && time < spanEnd) {\n          valid = false;\n          break;\n        } // Time exceeds the end time of the media file\n\n\n        if (time / 1000 > duration) {\n          valid = false;\n          break;\n        }\n      }\n\n      return valid;\n    }\n  }, {\n    key: \"doesTimespanOverlap\",\n    value: function doesTimespanOverlap(beginTime, endTime, allSpans) {\n      var toMs = this.toMs; // Filter out only spans where new begin time is before an existing begin time\n\n      var filteredSpans = allSpans.filter(function (span) {\n        return toMs(beginTime) < toMs(span.begin);\n      }); // Return whether new end time overlaps the next begin time, if there are timespans after the current timespan\n\n      if (filteredSpans.length !== 0) {\n        return toMs(endTime) > toMs(filteredSpans[0].begin);\n      }\n\n      return false;\n    }\n    /**\n     * Find an item by it's id\n     * @param {String} id - string value to match against\n     * @param {Array} items - Array of nested structured metadata objects containing headings and time spans\n     * @return {Object} - Object found, or null if none\n     */\n\n  }, {\n    key: \"findItem\",\n    value: function findItem(id, items) {\n      var foundItem = null;\n\n      var fn = function fn(items) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = items[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var item = _step2.value;\n\n            if (item.id === id) {\n              foundItem = item;\n            }\n\n            if (item.items && item.items.length > 0) {\n              fn(item.items);\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n              _iterator2[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      };\n\n      fn(items);\n      return foundItem;\n    }\n    /**\n     * Find the <span>s which come before and after new span\n     * @param {Object} newSpan - new span object\n     * @param {Array} allSpans - all type <span> objects in current structured metadata\n     * @returns {Object} - wrapper <span>s object: { before: spanObject, after: spanObject }\n     */\n\n  }, {\n    key: \"findWrapperSpans\",\n    value: function findWrapperSpans(newSpan, allSpans) {\n      var toMs = this.toMs;\n      var wrapperSpans = {\n        before: null,\n        after: null\n      };\n      var spansBefore = allSpans.filter(function (span) {\n        return toMs(newSpan.begin) >= toMs(span.end);\n      });\n      var spansAfter = allSpans.filter(function (span) {\n        return toMs(newSpan.end) <= toMs(span.begin);\n      });\n      wrapperSpans.before = spansBefore.length > 0 ? spansBefore[spansBefore.length - 1] : null;\n      wrapperSpans.after = spansAfter.length > 0 ? spansAfter[0] : null;\n      return wrapperSpans;\n    }\n    /**\n     * Find the <div>s wrapping the current active timespan (either in editing or in drag-n-drop)\n     * @param {Object} parentDiv - parent header of the active timespan\n     * @param {Array} allItems - all the items in the structured metadata\n     */\n\n  }, {\n    key: \"findWrapperHeaders\",\n    value: function findWrapperHeaders(parentDiv, allItems) {\n      var wrapperHeadings = {\n        before: null,\n        after: null\n      };\n      var grandParentDiv = this.getParentDiv(parentDiv, allItems);\n\n      if (grandParentDiv != null) {\n        var grandParentItems = grandParentDiv.items.filter(function (item) {\n          return item.type !== 'optional';\n        });\n        var parentIndex = grandParentItems.map(function (item) {\n          return item.label;\n        }).indexOf(parentDiv.label);\n        wrapperHeadings.before = grandParentItems[parentIndex - 1] !== undefined ? grandParentItems[parentIndex - 1] : null;\n        wrapperHeadings.after = grandParentItems[parentIndex + 1] !== undefined ? grandParentItems[parentIndex + 1] : null;\n      }\n\n      return wrapperHeadings;\n    }\n    /**\n     * Get all items in data structure of type 'div' or 'span'\n     * @param {Array} json\n     * @returns {Array} - all stripped down objects of type in the entire structured metadata collection\n     */\n\n  }, {\n    key: \"getItemsOfType\",\n    value: function getItemsOfType() {\n      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'div';\n      var items = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var options = []; // Recursive function to search the whole data structure\n\n      var getItems = function getItems(items) {\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = items[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var item = _step3.value;\n\n            if (item.type === type) {\n              var currentObj = (0, _objectSpread2[\"default\"])({}, item);\n              delete currentObj.items;\n              options.push(currentObj);\n            }\n\n            if (item.items) {\n              getItems(item.items);\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n              _iterator3[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      };\n\n      getItems(items);\n      return options;\n    }\n  }, {\n    key: \"getParentDiv\",\n    value: function getParentDiv(child, allItems) {\n      var foundDiv = null;\n\n      var findItem = function findItem(child, items) {\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = items[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var item = _step4.value;\n\n            if (item.items) {\n              var childItem = item.items.filter(function (currentChild) {\n                return child.id === currentChild.id;\n              }); // Found it\n\n              if (childItem.length > 0) {\n                foundDiv = item;\n                break;\n              }\n\n              findItem(child, item.items);\n            }\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n              _iterator4[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      };\n\n      findItem(child, allItems);\n      return foundDiv;\n    }\n    /**\n     * Overall logic is to find existing before and after spans for the new object (time flow), and then\n     * their parent 'divs' would be valid headings.\n     * @param {Object} wrapperSpans Object representing before and after spans of newSpan (if they exist)\n     * @param {Array} allItems - All structural metadata items in tree\n     * @return {Array} - of valid <div> objects in structural metadata tree\n     */\n\n  }, {\n    key: \"getValidHeadings\",\n    value: function getValidHeadings(wrapperSpans, allItems) {\n      var validHeadings = [];\n      var sortedHeadings = [];\n\n      var findSpanItem = function findSpanItem(targetSpan, items) {\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = items[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var item = _step5.value; // Children items exist\n\n            if (item.items) {\n              // Check for a target span match\n              var targetSpanMatch = item.items.filter(function (childItem) {\n                return childItem.id === targetSpan.id;\n              }); // Match found\n\n              if (targetSpanMatch.length > 0) {\n                var _items = item.items,\n                    cloneWOItems = (0, _objectWithoutProperties2[\"default\"])(item, [\"items\"]); // Add parent div to valid array\n\n                validHeadings.push(cloneWOItems);\n              } // Try deeper in list\n\n\n              findSpanItem(targetSpan, item.items);\n            }\n          }\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5[\"return\"] != null) {\n              _iterator5[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n      }; // Get all headings in the metada structure\n\n\n      var allHeadings = this.getItemsOfType('div', allItems).concat(this.getItemsOfType('root', allItems)); // There are currently no spans, ALL headings are valid\n\n      if (!wrapperSpans.before && !wrapperSpans.after) {\n        validHeadings = allHeadings;\n      }\n\n      if (wrapperSpans.before) {\n        findSpanItem(wrapperSpans.before, allItems);\n      }\n\n      if (wrapperSpans.after) {\n        findSpanItem(wrapperSpans.after, allItems);\n      } // Get valid headings when either of wrapping timespan is null\n\n\n      if (!wrapperSpans.before && wrapperSpans.after || wrapperSpans.before && !wrapperSpans.after) {\n        var validDivHeading = this.getValidHeadingForEmptySpans(wrapperSpans, allItems);\n        validHeadings = validHeadings.concat(validDivHeading);\n      } // Sort valid headings to comply with the order in the metadata structure\n\n\n      allHeadings.forEach(function (key) {\n        var found = false;\n        validHeadings = validHeadings.filter(function (heading) {\n          if (!found && heading.label === key.label) {\n            sortedHeadings.push(heading);\n            found = true;\n            return false;\n          } else {\n            return true;\n          }\n        });\n      });\n      return sortedHeadings;\n    }\n    /**\n     * Find valid headings when either wrapping timespan before or after is null\n     * @param {Object} wrapperSpans - spans wrapping the current active timespan\n     * @param {Array} allItems - all the items in structured metadata\n     */\n\n  }, {\n    key: \"getValidHeadingForEmptySpans\",\n    value: function getValidHeadingForEmptySpans(wrapperSpans, allItems) {\n      var _this3 = this;\n\n      var adjacentDiv = null;\n\n      var getWrapperDiv = function getWrapperDiv(currentParent, position) {\n        var wrapperParents = _this3.findWrapperHeaders(currentParent, allItems);\n\n        switch (position) {\n          case 'before':\n            return !wrapperParents.before ? currentParent : wrapperParents.before;\n\n          case 'after':\n            return !wrapperParents.after ? currentParent : wrapperParents.after;\n\n          default:\n            return currentParent;\n        }\n      };\n\n      var nestedHeadings = [];\n\n      var getNestedDivs = function getNestedDivs(currentHeader, currentParent) {\n        if (currentHeader !== currentParent) {\n          var _items2 = currentHeader.items;\n\n          if (_items2) {\n            var _iteratorNormalCompletion6 = true;\n            var _didIteratorError6 = false;\n            var _iteratorError6 = undefined;\n\n            try {\n              for (var _iterator6 = _items2[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                var item = _step6.value;\n\n                if (item.type === 'div') {\n                  var _items3 = item.items,\n                      cloneWOItems = (0, _objectWithoutProperties2[\"default\"])(item, [\"items\"]);\n                  nestedHeadings.push(cloneWOItems);\n                }\n\n                getNestedDivs(item, currentParent);\n              }\n            } catch (err) {\n              _didIteratorError6 = true;\n              _iteratorError6 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion6 && _iterator6[\"return\"] != null) {\n                  _iterator6[\"return\"]();\n                }\n              } finally {\n                if (_didIteratorError6) {\n                  throw _iteratorError6;\n                }\n              }\n            }\n          }\n        }\n      };\n\n      if (!wrapperSpans.after && wrapperSpans.before) {\n        var currentParent = this.getParentDiv(wrapperSpans.before, allItems);\n        adjacentDiv = getWrapperDiv(currentParent, 'after');\n        getNestedDivs(adjacentDiv, currentParent);\n      }\n\n      if (!wrapperSpans.before && wrapperSpans.after) {\n        var _currentParent = this.getParentDiv(wrapperSpans.after, allItems);\n\n        adjacentDiv = getWrapperDiv(_currentParent, 'before');\n        getNestedDivs(adjacentDiv, _currentParent);\n      }\n\n      var _adjacentDiv = adjacentDiv,\n          items = _adjacentDiv.items,\n          woItems = (0, _objectWithoutProperties2[\"default\"])(_adjacentDiv, [\"items\"]);\n      nestedHeadings.push(woItems);\n      return nestedHeadings;\n    }\n    /**\n     * Helper function which handles React Dnd's dropping of a dragSource onto a dropTarget\n     * It needs to re-arrange the data structure to reflect the new positions\n     * @param {Object} dragSource - a minimal object React DnD uses with only the id value\n     * @param {Object} dropTarget\n     * @param {Array} allItems\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"handleListItemDrop\",\n    value: function handleListItemDrop(dragSource, dropTarget, allItems) {\n      var clonedItems = (0, _lodash.cloneDeep)(allItems);\n      var itemToMove = this.findItem(dragSource.id, clonedItems); // Slice out previous position of itemToMove\n\n      var itemToMoveParent = this.getParentDiv(itemToMove, clonedItems);\n      var itemToMoveItemIndex = itemToMoveParent.items.map(function (item) {\n        return item.id;\n      }).indexOf(itemToMove.id);\n      itemToMoveParent.items.splice(itemToMoveItemIndex, 1); // Place itemToMove right after the placeholder array position\n\n      var dropTargetParent = this.getParentDiv(dropTarget, clonedItems);\n      var dropTargetItemIndex = dropTargetParent.items.map(function (item) {\n        return item.id;\n      }).indexOf(dropTarget.id);\n      dropTargetParent.items.splice(dropTargetItemIndex, 0, itemToMove); // Get rid of all placeholder elements\n\n      return this.removeDropTargets(clonedItems);\n    }\n    /**\n     * Insert a new heading as child of an existing heading\n     * @param {Object} obj - new heading object to insert\n     * @param {Array} allItems - The entire structured metadata collection\n     * @returns {Array} - The updated structured metadata collection, with new object inserted\n     */\n\n  }, {\n    key: \"insertNewHeader\",\n    value: function insertNewHeader(obj, allItems) {\n      var clonedItems = (0, _lodash.cloneDeep)(allItems);\n      var foundDiv = this.findItem(obj.headingChildOf, clonedItems) || clonedItems[0]; // If children exist, add to list\n\n      if (foundDiv) {\n        foundDiv.items.push({\n          id: (0, _v[\"default\"])(),\n          type: 'div',\n          label: obj.headingTitle,\n          items: []\n        });\n      }\n\n      return clonedItems;\n    }\n    /**\n     * Insert a new timespan as child of an existing heading\n     * @param {Object} obj - object of form values submitted\n     * @param {Array} allItems - The entire structured metadata collection\n     * @returns ({Object}, {Array}) - (New span, The updated structured metadata collection, with new object inserted)\n     */\n\n  }, {\n    key: \"insertNewTimespan\",\n    value: function insertNewTimespan(obj, allItems) {\n      var _this4 = this;\n\n      var toMs = this.toMs;\n      var clonedItems = (0, _lodash.cloneDeep)(allItems);\n      var foundDiv = this.findItem(obj.timespanChildOf, clonedItems);\n      var spanObj = this.createSpanObject(obj);\n      var insertIndex = 0;\n      var nestedTimespans = [];\n\n      var findNestedTimespans = function findNestedTimespans(header) {\n        var items = header.items;\n        var _iteratorNormalCompletion7 = true;\n        var _didIteratorError7 = false;\n        var _iteratorError7 = undefined;\n\n        try {\n          for (var _iterator7 = items[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n            var item = _step7.value;\n\n            if (item.type === 'span' && toMs(spanObj.begin) > toMs(item.end)) {\n              nestedTimespans.push(item);\n            }\n          }\n        } catch (err) {\n          _didIteratorError7 = true;\n          _iteratorError7 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion7 && _iterator7[\"return\"] != null) {\n              _iterator7[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError7) {\n              throw _iteratorError7;\n            }\n          }\n        }\n      }; // If children exist, add to list\n\n\n      if (foundDiv) {\n        var childSpans = foundDiv.items.filter(function (item) {\n          return item.type === 'span';\n        });\n        var nestedHeaders = foundDiv.items.filter(function (item) {\n          return item.type === 'div';\n        });\n        var _iteratorNormalCompletion8 = true;\n        var _didIteratorError8 = false;\n        var _iteratorError8 = undefined;\n\n        try {\n          for (var _iterator8 = nestedHeaders[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n            var header = _step8.value;\n            findNestedTimespans(header);\n          } // Add nested timespans from child items and sort by begin time\n\n        } catch (err) {\n          _didIteratorError8 = true;\n          _iteratorError8 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion8 && _iterator8[\"return\"] != null) {\n              _iterator8[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError8) {\n              throw _iteratorError8;\n            }\n          }\n        }\n\n        childSpans = childSpans.concat(nestedTimespans).sort(function (x, y) {\n          return _this4.toMs(x['begin']) - _this4.toMs(y['begin']);\n        }); // Get before and after sibling spans\n\n        var wrapperSpans = this.findWrapperSpans(spanObj, childSpans);\n\n        if (wrapperSpans.before) {\n          var wrapperSpanParent = this.getParentDiv(wrapperSpans.before, allItems);\n\n          if (wrapperSpanParent.id !== foundDiv.id) {\n            insertIndex = (0, _lodash.findIndex)(foundDiv.items, {\n              id: wrapperSpanParent.id\n            }) + 1;\n          } else {\n            insertIndex = (0, _lodash.findIndex)(foundDiv.items, {\n              id: wrapperSpans.before.id\n            }) + 1;\n          }\n        } // Insert new span at appropriate index\n\n\n        foundDiv.items.splice(insertIndex, 0, spanObj);\n      }\n\n      return {\n        newSpan: spanObj,\n        updatedData: clonedItems\n      };\n    }\n    /**\n     * Recursive function to clean out any 'active' drag item property in the data structure\n     * @param {Array} allItems\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"removeActiveDragSources\",\n    value: function removeActiveDragSources(allItems) {\n      var removeActive = function removeActive(parent) {\n        if (!parent.items) {\n          if (parent.active) {\n            parent.active = false;\n          }\n\n          return parent;\n        }\n\n        parent.items = parent.items.map(function (child) {\n          return removeActive(child);\n        });\n        return parent;\n      };\n\n      var cleanItems = removeActive(allItems[0]);\n      return [cleanItems];\n    }\n    /**\n     * Recursive function to remove all temporary Drop Target objects from the structured metadata items\n     * @param {Array} allItems\n     */\n\n  }, {\n    key: \"removeDropTargets\",\n    value: function removeDropTargets(allItems) {\n      var clonedItems = (0, _lodash.cloneDeep)(allItems);\n\n      var removeFromTree = function removeFromTree(parent, childTypeToRemove) {\n        if (!parent.items) {\n          return parent;\n        }\n\n        parent.items = parent.items.filter(function (child) {\n          return child.type !== childTypeToRemove;\n        }).map(function (child) {\n          return removeFromTree(child, childTypeToRemove);\n        });\n        return parent;\n      };\n\n      var cleanItems = removeFromTree(clonedItems[0], 'optional');\n      return [cleanItems];\n    }\n    /**\n     * Does 'before' time start prior to 'end' time?\n     * @param {String} begin form intput value\n     * @param {String} end form input value\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"validateBeforeEndTimeOrder\",\n    value: function validateBeforeEndTimeOrder(begin, end) {\n      if (!begin || !end) {\n        return true;\n      }\n\n      if (this.toMs(begin) >= this.toMs(end)) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"validTimeFormat\",\n    value: function validTimeFormat(value) {\n      return value && value.split(':').length === 3;\n    }\n    /**\n     * This function adds a unique, front-end only id, to every object in the data structure\n     * @param {Array} structureJS\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"addUUIds\",\n    value: function addUUIds(structureJS) {\n      var structureWithIds = (0, _lodash.cloneDeep)(structureJS); // Recursively loop through data structure\n\n      var fn = function fn(items) {\n        var _iteratorNormalCompletion9 = true;\n        var _didIteratorError9 = false;\n        var _iteratorError9 = undefined;\n\n        try {\n          for (var _iterator9 = items[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n            var item = _step9.value; // Create and add an id\n\n            item.id = (0, _v[\"default\"])(); // Send child items back into the function\n\n            if (item.items && item.items.length > 0) {\n              fn(item.items);\n            }\n          }\n        } catch (err) {\n          _didIteratorError9 = true;\n          _iteratorError9 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion9 && _iterator9[\"return\"] != null) {\n              _iterator9[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError9) {\n              throw _iteratorError9;\n            }\n          }\n        }\n      };\n\n      fn(structureWithIds);\n      return structureWithIds;\n    }\n    /**\n     * Mark the top element as 'root' to help when creating list items\n     * The top elemetn should not have a delete icon\n     * @param {Array} smData - array of structured metadata\n     */\n\n  }, {\n    key: \"markRootElement\",\n    value: function markRootElement(smData) {\n      if (smData.length > 0) {\n        smData[0].type = 'root';\n      }\n    }\n    /**\n     * Moment.js helper millisecond converter to make calculations consistent\n     * @param {String} strTime form input value\n     */\n\n  }, {\n    key: \"toMs\",\n    value: function toMs(strTime) {\n      return _moment[\"default\"].duration(strTime).asMilliseconds();\n    }\n    /**\n     * Convert seconds to string format hh:mm:ss\n     * @param {Number} secTime - time in seconds\n     */\n\n  }, {\n    key: \"toHHmmss\",\n    value: function toHHmmss(secTime) {\n      var sec_num = this.roundOff(secTime);\n      var hours = Math.floor(sec_num / 3600);\n      var minutes = Math.floor(sec_num / 60);\n      var seconds = sec_num - minutes * 60 - hours * 3600;\n      var hourStr = hours < 10 ? \"0\".concat(hours) : \"\".concat(hours);\n      var minStr = minutes < 10 ? \"0\".concat(minutes) : \"\".concat(minutes);\n      var secStr = seconds.toFixed(2);\n      secStr = seconds < 10 ? \"0\".concat(secStr) : \"\".concat(secStr);\n      return \"\".concat(hourStr, \":\").concat(minStr, \":\").concat(secStr);\n    }\n  }, {\n    key: \"roundOff\",\n    value: function roundOff(value) {\n      var valueString = '';\n\n      var _value$toString$split = value.toString().split('.'),\n          _value$toString$split2 = (0, _slicedToArray2[\"default\"])(_value$toString$split, 2),\n          intVal = _value$toString$split2[0],\n          decVal = _value$toString$split2[1];\n\n      if (!decVal) {\n        valueString = intVal;\n      } else {\n        valueString = intVal + '.' + decVal.substring(0, 2);\n      }\n\n      return parseFloat(valueString);\n    }\n  }]);\n  return StructuralMetadataUtils;\n}();\n\nexports[\"default\"] = StructuralMetadataUtils;","map":null,"metadata":{},"sourceType":"module"}